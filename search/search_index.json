{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to daidai","text":"daidai \ud83c\udf4a <p> Modern dependency &amp; assets management library for MLOps </p> <p> </p> <p>daidai \ud83c\udf4a is a minimalist, type-safe dependency management system for AI/ML components that streamlines workflow development with dependency injection, intelligent caching and seamless file handling.</p> <p>\ud83d\udea7 daidai is still very much a work in progress and is definitely not prod-ready. It is currently developed as a selfish software to become my personal go-to MLOps library, but feel free to give it a try :) \ud83d\udea7</p> \ud83c\udfa7 Stop reading, listen to daidai \ud83c\udf4a's podcast instead \ud83c\udf99\ufe0f <p></p>"},{"location":"#why-daidai","title":"Why daidai?","text":"<p>Built for both rapid prototyping and production ML workflows, daidai \ud83c\udf4a:</p> <ul> <li>\ud83d\ude80 Accelerates Development - Reduces iteration cycles with zero-config caching</li> <li>\ud83e\udde9 Simplifies Architecture - Define reusable components with clear dependencies</li> <li>\ud83d\udd0c Works Anywhere - Seamless integration with cloud/local storage via fsspec (local, s3, gcs, az, ftp, hf..)</li> <li>\ud83e\udde0 Stays Out of Your Way - Type-hint based DI means minimal boilerplate</li> <li>\ud83e\uddf9 Manages Resources - Automatic cleanup prevents leaks and wasted compute</li> <li>\ud83e\uddea Enables Testing - Inject mock dependencies / stubs with ease for robust unit testing</li> <li>\ud83e\udeb6 Requires Zero Dependencies - Zero-dependency Core philosophy, install optionals at will</li> <li>\u03bb Promotes Functional Thinking - Embraces pure functions, immutability, and composition for predictable workflows</li> <li>\ud83e\uddf0 Adapts to Your Design - pure functions enable seamless integration with your preferred caching, versioning, validation systems..</li> </ul> <p>daidai is named after the Japanese word for \"orange\" \ud83c\udf4a, a fruit that is both sweet and sour, just like the experience of managing dependencies in ML projects. It is being developed with user happiness in mind, while providing great flexibility and minimal boilerplate. It has been inspired by pytest, modelkit, dependency injection &amp; testing principles and functional programming.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># Core functionality of assets &amp; predictors\npip install daidai\n\n# Full installation with all features: artifacts, memory tracking, CLI\npip install daidai[all] # or any combination of [artifacts, memory, cli]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import base64\nfrom typing import Annotated, Any\n\nimport openai\n\nfrom daidai import ModelManager, asset, predictor\n\n# Define assets which are long-lived objects\n# that can be used by multiple predictors, or other assets\n@asset\ndef openai_client(**configuration: dict[str, Any]) -&gt; openai.OpenAI:\n    return openai.OpenAI(**configuration)\n\n# Fetch a distant file from HTTPS, but it can be from any source: local, S3, GCS, Azure, FTP, HF Hub, etc.\n@asset\ndef dogo_picture(\n    picture: Annotated[\n        bytes,\n        \"https://images.pexels.com/photos/220938/pexels-photo-220938.jpeg\",\n        {\"cache_strategy\": \"no_cache\"},\n    ],\n) -&gt; str:\n    return base64.b64encode(picture).decode(\"utf-8\")\n\n\n# Define a predictor that depends on the previous assets\n# which are automatically loaded and passed as an argument\n@predictor\ndef ask(\n    message: str,\n    dogo_picture: Annotated[str, dogo_picture],\n    client: Annotated[openai.OpenAI, openai_client, {\"timeout\": 5}],\n    model: str = \"gpt-4o-mini\",\n) -&gt; str:\n    response = client.chat.completions.create(\n        messages=[\n            {\n                \"role\": \"user\",\n                \"content\": [\n                    {\"type\": \"text\", \"text\": message},\n                    {\n                        \"type\": \"image_url\",\n                        \"image_url\": {\n                            \"url\": f\"data:image/jpeg;base64,{dogo_picture}\",\n                            \"detail\": \"low\",\n                        },\n                    },\n                ],\n            }\n        ],\n        model=model,\n    )\n    return response.choices[0].message.content\n\n# daidai takes care of loading dependencies &amp; injecting assets!\nprint(ask(\"Hello, what's in the picture ?\"))\n# &gt;&gt;&gt; The picture features a dog with a black and white coat.\n\n# Or manage lifecycle with context manager for production usage\n# all predictors, assets and artifacts are automatically loaded and cleaned up\nwith ModelManager(preload=[ask]):\n    print(ask(\"Hello, what's in the picture ?\"))\n\n# or manually pass dependencies\nmy_other_openai_client = openai.OpenAI(timeout=0.1)\nprint(ask(\"Hello, what's in the picture ?\", client=my_other_openai_client))\n# &gt;&gt;&gt; openai.APITimeoutError: Request timed out.\n# OOOPS, the new client timed out, of course :-)\n</code></pre> <p>You can visualize the dependency graph of the above code using the <code>daidai CLI</code>:</p> <pre><code>$ daidai list -m example.py\n\n\ud83d\udce6 Daidai Components\n\u251c\u2500\u2500 \ud83d\udcc4 Artifacts\n\u2502   \u2514\u2500\u2500 https://images.pexels.com/photos/220938/pexels-photo-220938.jpeg\n\u2502       \u251c\u2500\u2500 Cache strategies: no_cache\n\u2502       \u2514\u2500\u2500 Used by:\n\u2502           \u2514\u2500\u2500 dogo_picture (asset) as picture\n\u251c\u2500\u2500 \ud83e\udde9 Assets\n\u2502   \u251c\u2500\u2500 openai_client\n\u2502   \u2514\u2500\u2500 dogo_picture\n\u2502       \u2514\u2500\u2500 Artifacts\n\u2502           \u2514\u2500\u2500 picture: https://images.pexels.com/photos/220938/pexels-photo-220938.jpeg - Cache: no_cache\n\u2514\u2500\u2500 \ud83d\udd2e Predictors\n    \u2514\u2500\u2500 ask\n        \u2514\u2500\u2500 Dependencies\n            \u251c\u2500\u2500 dogo_picture: dogo_picture (asset) - default\n            \u2514\u2500\u2500 client: openai_client (asset) - timeout=5\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Clean things up now that the UX has landed</li> <li> Protect file operations for parallelism / concurrency</li> <li> Add docs</li> <li> Add tests (unit, integration, e2e)</li> <li> Add a cookbook with common patterns &amp; recipes</li> <li> Add support for async components</li> <li> Enjoy the fruits of my labor \ud83c\udf4a</li> </ul>"},{"location":"#core-concepts","title":"\ud83e\udde0 Core Concepts","text":"<p><code>daidai</code> is built around a few key concepts that work together to provide a streamlined experience for developing and deploying ML components. The following explains these core concepts and how they interact.</p> <p>At the heart of <code>daidai</code> are three types of components: Assets, Predictors and Artifacts.</p> <p>TL;DR Predictors are functions that perform computations, Assets are long-lived objects that are expensive to create and should be reused, and Artifacts are the raw files, model weights, and other resources that assets transform into usable components.</p>"},{"location":"#assets","title":"\ud83e\udde9 Assets","text":"<p>Assets represent long-lived objects that are typically expensive to create and should be reused across multiple operations, e.g.: Loaded ML models (or parts of: weights etc.), Embedding models, Customer Configurations, Tokenizers, Database connections, API clients..</p> <p>Assets have several important characteristics:</p> <ol> <li>They are computed once and cached, making them efficient for repeated use</li> <li>They can depend on other assets or artifacts</li> <li>They are automatically cleaned up when no longer needed</li> <li>They can implement resource cleanup through generator functions</li> </ol> <p>Assets are defined using the <code>@asset</code> decorator:</p> <pre><code>@asset\ndef bert_model(\n    model_path: Annotated[Path, \"s3://models/bert-base.pt\"]\n) -&gt; BertModel:\n    return BertModel.from_pretrained(model_path)\n</code></pre>"},{"location":"#predictors","title":"\ud83d\udd2e Predictors","text":"<p>Predictors are functions that use assets to perform actual computations or predictions. Unlike assets:</p> <ol> <li>They are not cached themselves</li> <li>They are meant to be called repeatedly with different inputs</li> <li>They can depend on multiple assets or even other predictors</li> <li>They focus on the business logic of your application</li> </ol> <p>Predictors are defined using the <code>@predictor</code> decorator:</p> <pre><code>@predictor\ndef classify_text(\n    text: str,\n    model: Annotated[BertModel, bert_model],\n    tokenizer: Annotated[Tokenizer, tokenizer]\n) -&gt; str:\n    tokens = tokenizer(text)\n    prediction = model(tokens)\n    return prediction.label\n</code></pre>"},{"location":"#artifacts","title":"\ud83d\udce6 Artifacts","text":"<p>Artifacts represent the fundamental building blocks in your ML system - the raw files, model weights, configuration data, and other persistent resources that assets transform into usable components. They are discrete, versioned resources that can be stored, tracked, and managed across various storage systems.</p> <p>Artifacts have several important characteristics:</p> <ol> <li>They represent raw data resources that require minimal processing to retrieve</li> <li>They can be stored and accessed from a wide variety of storage systems</li> <li>They support flexible caching strategies to balance performance and resource usage</li> <li>They are automatically downloaded, cached, and managed by daidai</li> <li>They can be deserialized into various formats based on your needs</li> </ol> <p>Artifacts are defined using Python type annotations and are made vailable through the <code>artifacts</code> optional: <code>pip install daidai[artifacts]</code></p> <pre><code>@asset\ndef word_embeddings(\n    embeddings_file: Annotated[\n        Path,\n        \"s3://bucket/glove.txt\",  # Artifact location\n        {\"cache_strategy\": \"on_disk\"}\n    ]\n) -&gt; Dict[str, np.ndarray]:\n    with open(embeddings_file) as f:\n        embeddings = {...}\n        return embeddings\n</code></pre>"},{"location":"#working-together","title":"\ud83d\udce6\ud83e\udde9\ud83d\udd2e Working Together","text":"<p>The true power of daidai emerges when <code>Artifacts</code>, <code>Assets</code>, and <code>Predictors</code> work together in a cohesive dependency hierarchy.</p> <p>This architecture creates a natural progression from raw data to functional endpoints: <code>Artifacts</code> (raw files, model weights, configurations) are retrieved from storage systems, <code>Assets</code> transform these <code>artifacts</code> into reusable, long-lived objects, and <code>Predictors</code> utilize these <code>assets</code> to perform specific, business-logic computations.</p> <p>This clean separation of concerns allows each component to focus on its specific role while forming part of a larger, integrated system.</p>"},{"location":"#dependency-injection","title":"\ud83d\udc89 Dependency Injection","text":"<p><code>daidai</code> uses a type-hint based dependency injection system that minimizes boilerplate while providing type safety. The system works as follows:</p>"},{"location":"#type-annotations","title":"Type Annotations","text":"<p>Dependencies are declared using Python's <code>Annotated</code> type from the <code>typing</code> module:</p> <pre><code>param_name: Annotated[Type, Dependency, Optional[Configuration]]\n</code></pre> <p>Where:</p> <ul> <li><code>Type</code> is the expected type of the parameter</li> <li><code>Dependency</code> is the function that will be called to obtain the dependency</li> <li><code>Optional[Configuration]</code> is an optional dictionary of configuration parameters</li> </ul>"},{"location":"#automatic-resolution","title":"Automatic Resolution","text":"<p>When you call a predictor or asset, <code>daidai</code> automatically:</p> <ol> <li>Identifies all dependencies (predictors, assets and artifacts)</li> <li>Resolves the dependency graph</li> <li>Loads or retrieves cached dependencies</li> <li>Injects them into your function</li> </ol> <p>This happens transparently, so you can focus on your business logic rather than dependency management.</p> Simple Dependency Resolution Flowchart <p>For a single predictor with one asset dependency having one file dependency, the dependency resolution flow looks like this:</p> <pre><code>flowchart TD\n    A[User calls Predictor] --&gt; B{Predictor in cache?}\n\n    subgraph \"Dependency Resolution\"\n        B --&gt;|No| D[Resolve Dependencies]\n\n        subgraph \"Asset Resolution\"\n            D --&gt; E{Asset in cache?}\n            E --&gt;|No| G[Resolve Asset Dependencies]\n\n            subgraph \"File Handling\"\n                G --&gt; H{File in cache?}\n                H --&gt;|No| J[Download File]\n                J --&gt; K[Cache File based on Strategy]\n                K --&gt; I[Get Cached File]\n                H --&gt;|Yes| I\n            end\n\n            I --&gt; L[Deserialize File to Required Format]\n            L --&gt; M[Compute Asset with File]\n            M --&gt; N[Cache Asset]\n            N --&gt; F[Get Cached Asset]\n            E --&gt;|Yes| F\n        end\n\n        F --&gt; O[Create Predictor Partial Function]\n        O --&gt; P[Cache Prepared Predictor]\n    end\n\n    B --&gt;|Yes| C[Get Cached Predictor]\n    P --&gt; C\n\n    subgraph \"Execution\"\n        C --&gt; Q[Execute Predictor Function]\n    end\n\n    Q --&gt; R[Return Result to User]\n</code></pre>"},{"location":"#manual-overrides","title":"Manual Overrides","text":"<p>You can always override automatic dependency injection by explicitly passing values:</p> <pre><code># Normal automatic injection\nresult = classify_text(\"Sample text\")\n\n# Override with custom model\ncustom_model = load_my_custom_model()\nresult = classify_text(\"Sample text\", model=custom_model)\n</code></pre> <p>This way, you can easily swap out components for testing, debugging, or A/B testing.</p>"},{"location":"#artifacts-in-depth","title":"\ud83d\udce6 Artifacts (in-depth)","text":""},{"location":"#file-types","title":"File Types","text":"<p>daidai supports various file types through type hints, allowing you to specify exactly how you want to interact with the artifact:</p> <ul> <li><code>Path</code>: Returns a Path object pointing to the downloaded file, ideal for when you need to work with the file using standard file operations</li> <li><code>str</code>: Returns the file content as a string, useful for text-based configurations or small text files</li> <li><code>bytes</code>: Returns the file content as bytes, perfect for binary data like images or serialized models</li> <li><code>TextIO</code>: Returns a text file handle (similar to <code>open(file, \"r\")</code>), best for streaming large text files</li> <li><code>BinaryIO</code>: Returns a binary file handle (similar to <code>open(file, \"rb\")</code>), ideal for streaming large binary files</li> <li><code>Generator[str]</code>: Returns a generator that yields lines from the file, optimal for processing large text files line by line</li> <li><code>Generator[bytes]</code>: Returns a generator that yields chunks of binary data, useful for processing large binary files in chunks</li> </ul>"},{"location":"#cache-strategies","title":"Cache Strategies","text":"<p>daidai offers multiple caching strategies for artifacts to balance performance, storage use, and reliability:</p> <ul> <li><code>on_disk</code>: Download once and keep permanently in the cache directory. Ideal for stable artifacts that change infrequently.</li> <li><code>on_disk_temporary</code>: Download to a temporary location, automatically deleted when the process exits. Best for large artifacts needed only for the current session.</li> <li><code>no_cache</code>: Do not cache the artifact, fetch it each time. Useful for dynamic content that changes frequently or when running in environments with limited write permissions.</li> </ul>"},{"location":"#storage-systems","title":"Storage Systems","text":"<p>Thanks to <code>fsspec</code> integration, daidai supports a wide range of storage systems, allowing you to retrieve artifacts from virtually anywhere:</p> <ul> <li>Local file system for development and testing</li> <li>Amazon S3 for cloud-native workflows</li> <li>Google Cloud Storage for GCP-based systems</li> <li>Microsoft Azure Blob Storage for Azure environments</li> <li>SFTP/FTP for legacy or on-premises data</li> <li>HTTP/HTTPS for web-based resources</li> <li>Hugging Face Hub for ML models and datasets</li> <li>And many more through fsspec protocols</li> </ul> <p>This unified access layer means your code remains the same regardless of where your artifacts are stored, making it easy to transition from local development to cloud deployment.</p>"},{"location":"#resource-lifecycle-management","title":"\ud83e\uddf9 Resource Lifecycle Management","text":"<p><code>daidai</code> automatically manages the lifecycle of resources to prevent leaks and ensure clean shutdown:</p>"},{"location":"#automatic-cleanup","title":"Automatic Cleanup","text":"<p>For basic resources, assets are automatically released when they're no longer needed. For resources requiring explicit cleanup (like database connections), <code>daidai</code> supports generator-based cleanup:</p> <pre><code>@asset\ndef database_connection(db_url: str):\n    # Establish connection\n    conn = create_connection(db_url)\n    try:\n        yield conn  # Return the connection for use\n    finally:\n        conn.close()  # This runs during cleanup\n</code></pre>"},{"location":"#modelmanager","title":"ModelManager","text":"<p>The <code>ModelManager</code> class provides explicit control over component lifecycle and is the recommended way for production usage:</p> <pre><code># Preload components and manage their lifecycle\nwith ModelManager(preload=[classify_text]) as manager:\n    # Components are ready to use\n    result = classify_text(\"Sample input\")\n    # More operations...\n# All resources are automatically cleaned up\n</code></pre> <p>ModelManager features:</p> <ul> <li>Preloading of components for predictable startup times</li> <li>Namespace isolation for managing different environments</li> <li>Explicit cleanup on exit</li> <li>Support for custom configuration</li> </ul>"},{"location":"#namespaces","title":"Namespaces","text":"<p><code>daidai</code> supports isolating components into namespaces, which is useful for:</p> <ul> <li>Running multiple model versions concurrently</li> <li>Testing with different configurations</li> <li>Implementing A/B testing</li> </ul> <pre><code># Production namespace\nwith ModelManager(preload=[model_v1], namespace=\"prod\"):\n    # Development namespace in the same process\n    with ModelManager(preload=[model_v2], namespace=\"dev\"):\n        # Both can be used without conflicts\n        prod_result = model_v1(\"input\")\n        dev_result = model_v2(\"input\")\n</code></pre>"},{"location":"#caching-and-performance","title":"Caching and Performance","text":"<p><code>daidai</code> implements intelligent caching to optimize performance:</p> <ul> <li>Assets are cached based on their configuration parameters</li> <li>Artifacts use a content-addressed store for efficient storage</li> <li>Memory usage is tracked (when pympler is installed, <code>pip install daidai[memory]</code>)</li> <li>Cache invalidation is handled automatically based on dependency changes</li> </ul> <p>This ensures your ML components load quickly while minimizing redundant computation and memory usage.</p>"},{"location":"#environment-configuration","title":"\ud83d\udd27 Environment Configuration","text":"<p><code>daidai</code> can be configured through environment variables:</p> <ul> <li><code>DAIDAI_CACHE_DIR</code>: Directory for persistent file cache</li> <li><code>DAIDAI_CACHE_DIR_TMP</code>: Directory for temporary file cache</li> <li><code>DAIDAI_DEFAULT_CACHE_STRATEGY</code>: Default strategy for file caching, so you don't have to specify it for each file</li> <li><code>DAIDAI_FORCE_DOWNLOAD</code>: Force download even if cached versions exist</li> <li><code>DAIDAI_LOG_LEVEL</code>: Logging verbosity level</li> </ul>"},{"location":"#adaptable-design","title":"\ud83e\uddf0 Adaptable Design","text":"<p><code>daidai</code> embraces an adaptable design philosophy that provides core functionality while allowing for extensive customization and extension. This approach enables you to integrate <code>daidai</code> into your existing ML infrastructure without forcing rigid patterns or workflows.</p>"},{"location":"#pure-functions-as-building-blocks","title":"Pure Functions as Building Blocks","text":"<p>At its core, <code>daidai</code> uses pure functions decorated with <code>@asset</code> and <code>@predictor</code> rather than class hierarchies or complex abstractions:</p> <pre><code>@asset\ndef embedding_model(model_path: Path) -&gt; Model:\n    return load_model(model_path)\n\n@predictor\ndef embed_text(text: str, model: Annotated[Model, embedding_model]) -&gt; np.ndarray:\n    return model.encode(text)\n</code></pre> <p>This functional approach provides several advantages:</p> <ol> <li>Composability: Functions can be easily composed together to create complex pipelines</li> <li>Testability: Pure functions with explicit dependencies are straightforward to test</li> <li>Transparency: The data flow between components is clear and traceable</li> <li>Interoperability: Functions work with any Python object, not just specialized classes</li> </ol>"},{"location":"#integration-with-external-systems","title":"Integration with External Systems","text":"<p>You can easily integrate <code>daidai</code> with external systems and frameworks:</p> <pre><code># Integration with existing ML experiment tracking\nimport mlflow\n@asset\ndef tracked_model(model_id: str, mlflow_uri: str) -&gt; Model:\n    mlflow.set_tracking_uri(mlflow_uri)\n    model_uri = f\"models:/{model_id}/Production\"\n    return mlflow.sklearn.load_model(model_uri)\n\n# Integration with metrics collection\n@predictor\ndef classified_with_metrics(\n    text: str,\n    model: Annotated[Model, classifier_model],\n    metrics_client: Annotated[MetricsClient, metrics]\n) -&gt; str:\n    result = model.predict(text)\n    metrics_client.increment(\"prediction_count\")\n    metrics_client.histogram(\"prediction_latency\", time.time() - start_time)\n    return result\n</code></pre>"},{"location":"#adding-your-own-capabilities","title":"Adding Your Own Capabilities","text":"<p><code>daidai</code> can be extended with additional capabilities by composing with other libraries:</p>"},{"location":"#inputoutput-validation-with-pydantic","title":"Input/Output Validation with Pydantic","text":"<pre><code># Apply validation to predictor\n@predictor\n@validate_call(validate_return=True)\ndef analyze_sentiment(\n    text: TextInput,\n    model: Annotated[Model, sentiment_model],\n    min_length: int = 1\n) -&gt; SentimentResult:\n    # Input has been validated\n    result = model.predict(text)\n    return SentimentResult(\n        sentiment=result.label,\n        confidence=result.score,\n    ) # Output will be validated\n</code></pre>"},{"location":"#performance-optimization-with-lru-cache","title":"Performance Optimization with LRU Cache","text":"<pre><code>from functools import lru_cache\n\n@lru_cache(maxsize=1000)\n@predictor\ndef classify_text(\n    text: str,\n    model: Annotated[Model, classifier_model]\n) -&gt; str:\n    # This result will be cached based on text if only text is provided (and model injected)\n    return model.predict(text)\n</code></pre>"},{"location":"#instrumentation-and-observability","title":"Instrumentation and Observability","text":"<pre><code>from opentelemetry import trace\nimport time\nfrom functools import wraps\n\ntracer = trace.get_tracer(__name__)\n\ndef traced_predictor(func):\n    \"\"\"Decorator to add tracing to predictors\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        with tracer.start_as_current_span(func.__name__):\n            return func(*args, **kwargs)\n    return wrapper\n\ndef timed_predictor(func):\n    \"\"\"Decorator to measure and log execution time\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        execution_time = time.perf_counter() - start_time\n        print(f\"{func.__name__} executed in {execution_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@predictor\n@traced_predictor\n@timed_predictor\ndef predict_with_instrumentation(\n    text: str,\n    model: Annotated[Model, model]\n) -&gt; str:\n    # This call will be traced and timed\n    return model.predict(text)\n</code></pre>"},{"location":"#replacing-components","title":"Replacing Components","text":"<p>The dependency injection system allows you to replace components at runtime without modifying any code:</p> <pre><code># Normal usage with automatic dependency resolution\nresult = embed_text(\"Example text\")\n\n# Replace the embedding model for A/B testing\nexperimental_model = load_experimental_model()\nresult_b = embed_text(\"Example text\", model=experimental_model)\n\n# Replace for a specific use case\nsmall_model = load_small_model()\nbatch_results = [embed_text(t, model=small_model) for t in large_batch]\n</code></pre> <p><code>daidai</code>'s adaptable design ensures that you can build ML systems that meet your specific requirements while still benefiting from the core dependency management and caching features. Whether you're working on a simple prototype or a complex production system, <code>daidai</code> provides the flexibility to adapt to your needs without getting in your way.</p>"},{"location":"#concurrency-parallelism","title":"\ud83e\uddf5 Concurrency &amp; Parallelism","text":"<p>While file operations are protected against race conditions (downloading, caching etc.), other operations are not due to the lazy nature of component loading. As such, <code>daidai</code> cannot be considered thread-safe and does not plan to in the short term.</p> <p>However, there are ways to work around this limitation for multi-threaded applications:</p> <ol> <li>Create a shared <code>ModelManager</code> instance for all threads, but ensure that components are loaded before the threads are started:</li> </ol> <pre><code>@asset\ndef model(model_path: Annotated[Path, \"s3://bucket/model.pkl\"]) -&gt; Model:\n    with open(model_path, \"rb\") as f:\n        return pickle.load(f)\n\n@predictor\ndef sentiment_classifier(text: str, model: Annotated[Model, model]):\n    return model.predict(text)\n\n\nwith ModelManager(preload=[sentiment_classifier]) as manager:\n    # sentiment_classifier and its dependencies (model) are loaded and\n    # ready to be used by all threads without issues\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        results = list(executor.map(worker_function, data_chunks))\n</code></pre> <ol> <li>Create a separate <code>ModelManager</code> instance for each thread, each will benefit from the same disk cache but will not share components:</li> </ol> <pre><code># same predictor &amp; asset definitions as above\n\ndef worker_function(data_chunk):\n    # Each thread has its own manager and namespace\n    with ModelManager(namespace=str(threading.get_ident())) as manager:\n        return my_predictor(data)\n\nwith ThreadPoolExecutor(max_workers=4) as executor:\n    results = list(executor.map(worker_function, data_chunks))\n</code></pre> <p>A few notes:</p> <ul> <li>Creating separate ModelManager instances (approach #2) might lead to duplicate loading of the same components in memory across threads, while preloading (approach #1) ensures components are shared but requires knowing &amp; loading all components in advance.</li> <li>For most applications, approach #2 (separate managers) provides the safest experience, while approach #1 (preloading) is more memory-efficient and simple to implement for applications with large models.</li> <li>Both approaches benefit from disk caching, so artifacts are only downloaded once regardless of how many ModelManager instances you create.</li> </ul>"},{"location":"#testing","title":"\ud83e\uddea Testing","text":"<p><code>daidai</code>'s design makes testing ML components straightforward and effective. The dependency injection pattern allows for clean separation of concerns and easy mocking of dependencies.</p>"},{"location":"#unit-testing-components","title":"Unit Testing Components","text":"<p>When unit testing assets or predictors, you can manually inject dependencies:</p> <pre><code>def test_text_classifier():\n    # Create a mock model that always returns \"positive\"\n    mock_model = lambda text: \"positive\"\n\n    # Pass the mock directly instead of using the real model\n    result = classify_text(\"Great product!\", model=mock_model)\n\n    assert result == \"positive\"\n</code></pre>"},{"location":"#testing-with-fixtures","title":"Testing with Fixtures","text":"<p>In pytest, you can create fixtures that provide mock assets:</p> <pre><code>import pytest\n\n@pytest.fixture\ndef mock_embedding_model():\n    # Return a simplified embedding model for testing\n    return lambda text: np.ones(768) * 0.1\n\ndef test_semantic_search(mock_embedding_model):\n    # Use the fixture as a dependency\n    results = search_documents(\n        \"test query\",\n        embedding_model=mock_embedding_model\n    )\n    assert len(results) &gt; 0\n</code></pre>"},{"location":"#integration-testing","title":"Integration Testing","text":"<p>For integration tests that verify the entire component pipeline:</p> <pre><code>@pytest.fixture(scope=\"module\")\ndef test_model_manager():\n    # Set up a test namespace with real components\n    with ModelManager(\n        preload=[classify_text],\n        namespace=\"test\"\n    ) as manager:\n        yield manager\n\ndef test_end_to_end_classification(test_model_manager):\n    # This will use real components in the test namespace\n    result = classify_text(\"Test input\")\n    assert result in [\"positive\", \"negative\", \"neutral\"]\n</code></pre>"},{"location":"#testing-artifacts","title":"Testing Artifacts","text":"<p>For artifacts, you can use local test files:</p> <pre><code>@asset\ndef test_embeddings(\n    embeddings_file: Annotated[\n        Path,\n        \"file:///path/to/test_embeddings.npy\"\n    ]\n) -&gt; np.ndarray:\n    return np.load(embeddings_file)\n\n# In your test\ndef test_with_test_embeddings():\n    result = embed_text(\"test\", embeddings=test_embeddings())\n    assert result.shape == (768,)\n</code></pre> <p><code>daidai</code>'s flexible design ensures that your ML components remain testable at all levels, from unit tests to integration tests, without requiring complex mocking frameworks or test setup.</p>"},{"location":"#resources","title":"\ud83d\udcda Resources","text":"<ul> <li>daidai \ud83c\udf4a Documentation</li> <li>daidai \ud83c\udf4a GitHub Repository</li> <li>daidai \ud83c\udf4a PyPI Package</li> </ul>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"}]}